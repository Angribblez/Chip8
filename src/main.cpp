//includes
#include <iostream>
#include <iomanip>
#include <fstream>
#include <stack>
#include <bitset>
#include <chrono>
#include <thread>

//memory and register setup
uint8_t memory[0x1000] = {
    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
    0x20, 0x60, 0x20, 0x20, 0x70, // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
    0x90, 0x90, 0xF0, 0x10, 0x10, // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
    0xF0, 0x10, 0x20, 0x40, 0x40, // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
    0xF0, 0x80, 0x80, 0x80, 0xF0, // C
    0xE0, 0x90, 0x90, 0x90, 0xE0, // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
    0xF0, 0x80, 0xF0, 0x80, 0x80  // F
};
bool display[0x800] = {0};
//display checkerboard:
/*uint8_t display[0xFF] = {
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55
};*/
uint16_t programCounter = 0x200;
uint16_t indexRegister = 0x0;
uint8_t registers[0x10] = {0};

//methods
void printMemory(int start, int end){
    //memory printer (DEBUG)
    for (int i = start; i < end; i++){
        if (i % 0x10 == 0 && i != 0){
            std::cout << std::endl;
        }
        std::cout << std::hex << std::setw(2) << std::setfill('0') << (int) memory[i] << " ";
    }
    std::cout << std::endl;
}
void drawDisplay(){
    for (int y = 0; y < 32; y++){
        for (int x = 0; x < 64; x++){
            bool pixel = display[y*64 + x];
            //std::cout << pixel << " ";
            if (pixel == true){
                std::cout << '#';
            }else{
                std::cout << ' ';
            }
        }
        std::cout << std::endl;
    }
}

#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
#define GET_OCTET(var, pos, size) (((var) & (0xF << (size*4-pos*4))) & 0xF)

int main(int argc, char *argv[]){
    //load file into memory using file name and size arguments
    int fileSize = atoi(argv[2]);
    std::ifstream file(argv[1], std::ios_base::binary);
    char bufferByte;
    for (int i = 0; i < fileSize; i++){
        file.read(&bufferByte, 1);
        memory[programCounter + i] = bufferByte;
    }

    //continuously read opcodes
    for(int z = 0; z > -1; z++){
        //load 2 byte opcode
        int16_t opcode = (memory[programCounter] << 8) + memory[programCounter+1];
        //std::cout << std::hex << std::setw(4) << std::setfill('0') << (int) opcode << " ";
        //std::cout << std::hex << std::setw(4) << std::setfill('0') << (int) (opcode & 0xF000) << " ";
        
        //check opcode and execute
        if (opcode == 0x00E0){
            //clear screen (00E0)
            for(int i = 0; i < 0xFF; i++){
                display[i] = 0x00;
            }
            //redraw screen
            drawDisplay();
            
            //increment program counter
            programCounter += 2;
        }else if((opcode & 0xF000) == 0x1000){
            //jump (1NNN)
            programCounter = opcode & 0x0FFF;
        }else if((opcode & 0xF000) == 0x6000){
            //set register vx (6XNN)
            registers[(opcode & 0x0F00) >> 0x8] = (int8_t) (opcode & 0x00FF);
            
            //increment program counter
            programCounter += 2;
        }else if((opcode & 0xF000) == 0x7000){
            //add value to register vx (7XNN)
            registers[(opcode & 0x0F00) >> 0x8] += (int8_t) (opcode & 0x00FF);
            
            //increment program counter
            programCounter += 2;
        }else if((opcode & 0xF000) == 0xA000){
            //set index register I (ANNN)
            indexRegister = opcode & 0x0FFF;
            
            //increment program counter
            programCounter += 2;
        }else if((opcode & 0xF000) == 0xD000){
            //display / draw (DXYN)
            //get coordinates and height
            int8_t x = registers[(opcode & 0x0F00) >> 0x8] % 64;
            int8_t y = registers[(opcode & 0x00F0) >> 0x4] % 32;
            int8_t h = (opcode & 0x000F) >> 0x0;

            //set VF to 0
            registers[0xF] = 0;

            //update memory
            for (int n = 0; n < h; n++){
                //get Nth byte of sprite data from memory at I
                int8_t lineData = memory[indexRegister + n];

                //go through each pixel in byte
                for (int i = 0; i < 8; i++){
                    //check if pixel in memory is on
                    if (CHECK_BIT(lineData, 7-i)){
                        //check if pixel is already on in screen
                        display[(y+n)*64 + (x+i)] = !display[(y+n)*64 + (x+i)];
                    }

                    //check if edge reached
                    if(x + i == 63){
                        break;
                    }
                }

                //check if edge reached
                if(y + n == 31){
                    break;
                }
            }

            //redraw screen
            drawDisplay();

            //increment program counter
            programCounter += 2;
        }
    }
}